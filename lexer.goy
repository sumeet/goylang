import "os"
import "fmt"

enum TokenType {
	FuncDecl,
	LParen,
	RParen,
	LCurly,
	RCurly,
	LBracket,
	RBracket,
	Ident,
	IntLiteral,
	Assignment,
	Reassignment,
	BinaryOp,
	Newline,
	Comma,
	StringLiteral,
	EnumDecl,
	Match,
	Dot,
	Colon,
	Import,
	Struct,
}

struct Token {
	Type TokenType,
	Value string,
}

func eqany(xs []byte, x byte) bool {
    imax := len(xs)
    i := 0
    while {
        if (i == imax) {
            return false
        }
        b := xs[i]
        if (x == b) {
            return true
        }
        i = i + 1
    }
}

func isAlphanumeric(b byte) bool {
  return isDigit(b) || isAlpha(b)
}

func peekInfixSymbol(dat []byte, start int) string {
    SymChars := bs("+-*/%=!<>&|")
    imax := len(dat)
    i := start
    while {
        if (i == imax) {
            break
        }
        ch := dat[i]
        if (eqany(SymChars, ch)) {
            i = i + 1
        } else {
            break
        }
    }
    return string(slice(dat, start, i))
}

func lex(dat []byte) []Token {
	tokens := []Token{}
	i := 0
	while {
		if (i >= len(dat)) {
			break
		} else if (nc(dat, i, " ") || nc(dat, i, "\t")) {
			i = i + 1
			continue
		} else if (nc(dat, i, "//")) {
			while {
				if (nc(dat, i, "\n")) {
					tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
					break
				} else {
					i = i + 1
				}
			}
		} else if (isAlpha(dat[i])) {
			ident := []byte{}
			while {
				if (isAlphanumeric(dat[i])) {
					ident = append(ident, dat[i])
					i = i + 1
				} else {
					if (string(ident) == "enum") {
						tokens = append(tokens, Token{TokenType.EnumDecl{}, string(ident)})
					} else if (string(ident) == "import") {
						tokens = append(tokens, Token{TokenType.Import{}, string(ident)})
					} else if (string(ident) == "struct") {
						tokens = append(tokens, Token{TokenType.Struct{}, string(ident)})
					} else {
						tokens = append(tokens, Token{TokenType.Ident{}, string(ident)})
					}
					break
				}
			}
			continue
		} else if (isDigit(dat[i])) {
		  n := []byte{}
		  while {
			if (isDigit(dat[i])) {
				n = append(n, dat[i])
				i = i + 1
			} else {
			  tokens = append(tokens, Token{TokenType.IntLiteral{}, string(n)})
			  break
			}
		  }
		} else if (nc(dat, i, "{")) {
			tokens = append(tokens, Token{TokenType.LCurly{}, "{"})
			i = i + 1
		} else if (nc(dat, i, "}")) {
			tokens = append(tokens, Token{TokenType.RCurly{}, "}"})
			i = i + 1
		} else if (nc(dat, i, "[")) {
			tokens = append(tokens, Token{TokenType.LBracket{}, "["})
			i = i + 1
		} else if (nc(dat, i, "]")) {
			tokens = append(tokens, Token{TokenType.RBracket{}, "]"})
			i = i + 1
		} else if (nc(dat, i, "(")) {
			tokens = append(tokens, Token{TokenType.LParen{}, "("})
			i = i + 1
		} else if (nc(dat, i, ")")) {
			tokens = append(tokens, Token{TokenType.RParen{}, ")"})
			i = i + 1
		} else if (nc(dat, i, "\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
			i = i + 1
		} else if (nc(dat, i, "\r\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\r\n"})
			i = i + 2
		} else if (nc(dat, i, ",")) {
			tokens = append(tokens, Token{TokenType.Comma{}, ","})
			i = i + 1
		} else if (nc(dat, i, ":")) {
			tokens = append(tokens, Token{TokenType.Colon{}, ":"})
			i = i + 1
		} else if (nc(dat, i, ".")) {
			tokens = append(tokens, Token{TokenType.Dot{}, "."})
			i = i + 1
		} else if (nc(dat, i, "\"")) {
			str := bs("\"")
			i = i + 1
			while {
				if (nc(dat, i, "\"")) {
					str = append(str, dat[i])
					i = i + 1
					break
				} else if (nc(dat, i, "\\\"")) {
					str = append(str, dat[i], dat[i + 1])
					i = i + 2
				} else {
					str = append(str, dat[i])
					i = i + 1
				}
			}
			tokens = append(tokens, Token{TokenType.StringLiteral{}, string(str)})
		} else {
            str := peekInfixSymbol(dat, i)
            if (len(str) > 0) {
                tokens = append(tokens, Token{TokenType.BinaryOp{}, str})
                i = i + len(str)
            } else {
                panic(sprintf("unexpected token: |%c|\n\ntokens so far: %#v", dat[i], tokens))
            }
		}
	}
	return tokens
}

enum Statement {
	Enum(Enum),
	Import(Import),
}

struct Program {
	Statements []Statement,
}

struct Import {
  Name string,
}

struct Enum {
	Name string,
}

func parseImport(tokens []Token) (Import, []Token) {
  t, tokens := consumeToken(tokens, TokenType.Import{})
  t, tokens = consumeToken(tokens, TokenType.StringLiteral{})
  name := t.Value
  return Import{name}, tokens
}

func parseEnum(tokens []Token) (Enum, []Token) {
  t, tokens := consumeToken(tokens, TokenType.EnumDecl{})
  t, tokens = consumeToken(tokens, TokenType.Ident{})
  e := Enum{}
  e.Name = t.Value
  t, tokens = consumeToken(tokens, TokenType.LCurly{})
  while {
    // TODO: why can't this be inlined?
    rcurly := TokenType.RCurly{}
    if (tokens[0].Type == rcurly) {
      t, tokens = consumeToken(tokens, TokenType.RCurly{})
      break
    }
    typ := tokens[0].Type
    t, tokens = consumeToken(tokens, typ)
  }
  return e, tokens
}

func parseStatement(tokens []Token) (Statement, []Token) {
	match (tokens[0].Type) {
		TokenType.Import{}: {
		  imp, tokens := parseImport(tokens)
		  return Statement.Import { imp }, tokens
    },
	  TokenType.EnumDecl{}: {
	  	e, tokens := parseEnum(tokens)
	  	return Statement.Enum { e }, tokens
	  },
	}
  panic(fmt.Sprintf("unexpected token: %#v", tokens[0]))
}

func parseProgram(tokens []Token) Program {
	p := Program{}
	while {
	  tokens = skipNewlines(tokens)
	  if (len(tokens) == 0) {
      break
	  }

	  statement, tokens2 := parseStatement(tokens)
	  tokens = tokens2
	  p.Statements = append(p.Statements, statement)
	}
	return p
}

func skipNewlines(tokens []Token) []Token {
	while {
	  match (tokens[0].Type) {
	    TokenType.Newline: {
	      tokens = slice(tokens, 1)
	      continue
      },
	  }
	  break
	}
	return tokens
}

func consumeToken(tokens []Token, expectedType TokenType) (Token, []Token) {
  if (len(tokens) == 0) {
    panic("Unexpected end of input")
  }
  nl := TokenType.Newline{}
  if (expectedType != nl) {
    tokens = skipNewlines(tokens)
  }
  if (tokens[0].Type != expectedType) {
		panic(fmt.Sprintf("Was expecting token %#v, got %#v", expectedType, tokens[0]))
  }
  return tokens[0], slice(tokens, 1)
}

func main() {
	dat, err := os.ReadFile("lexer.goy")
	if (err != nil) {
		panic(err)
	}
	tokens := lex(dat)
	print("Tokens:")
	print(tokens)
	program := parseProgram(tokens)
	print("Program:")
	print(program)
}
