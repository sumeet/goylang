import "os"
import "fmt"

enum TokenType {
	FuncDecl,
	LParen,
	RParen,
	LCurly,
	RCurly,
	LBracket,
	RBracket,
	Ident,
	IntLiteral,
	BinaryOp,
	Newline,
	Comma,
	StringLiteral,
	EnumDecl,
	Match,
	Dot,
	Colon,
	Equals,
	Import,
	Struct,
}

struct Token {
	Type TokenType,
	Value string,
}

func eqany(xs []byte, x byte) bool {
    imax := len(xs)
    i := 0
    while {
        if (i == imax) {
            return false
        }
        b := xs[i]
        if (x == b) {
            return true
        }
        i = i + 1
    }
}

func isAlphanumeric(b byte) bool {
  return isDigit(b) || isAlpha(b)
}

func peekInfixSymbol(dat []byte, start int) string {
    SymChars := bs("+-*/%=!<>&|")
    imax := len(dat)
    i := start
    while {
        if (i == imax) {
            break
        }
        ch := dat[i]
        if (eqany(SymChars, ch)) {
            i = i + 1
        } else {
            break
        }
    }
    return string(slice(dat, start, i))
}

func lex(dat []byte) []Token {
	tokens := []Token{}
	i := 0
	while {
		if (i >= len(dat)) {
			break
		} else if (nc(dat, i, " ") || nc(dat, i, "\t")) {
			i = i + 1
			continue
		} else if (nc(dat, i, "//")) {
			while {
				if (nc(dat, i, "\n")) {
					tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
					break
				} else {
					i = i + 1
				}
			}
		} else if (isAlpha(dat[i])) {
			ident := []byte{}
			while {
				if (isAlphanumeric(dat[i])) {
					ident = append(ident, dat[i])
					i = i + 1
				} else {
					if (string(ident) == "enum") {
						tokens = append(tokens, Token{TokenType.EnumDecl{}, string(ident)})
					} else if (string(ident) == "import") {
						tokens = append(tokens, Token{TokenType.Import{}, string(ident)})
					} else if (string(ident) == "struct") {
						tokens = append(tokens, Token{TokenType.Struct{}, string(ident)})
					} else if (string(ident) == "func") {
						tokens = append(tokens, Token{TokenType.FuncDecl{}, string(ident)})
					} else {
						tokens = append(tokens, Token{TokenType.Ident{}, string(ident)})
					}
					break
				}
			}
			continue
		} else if (isDigit(dat[i])) {
		  n := []byte{}
		  while {
			  if (isDigit(dat[i])) {
			  	n = append(n, dat[i])
			  	i = i + 1
			  } else {
			    tokens = append(tokens, Token{TokenType.IntLiteral{}, string(n)})
			    break
			  }
		  }
		} else if (nc(dat, i, "{")) {
			tokens = append(tokens, Token{TokenType.LCurly{}, "{"})
			i = i + 1
		} else if (nc(dat, i, "}")) {
			tokens = append(tokens, Token{TokenType.RCurly{}, "}"})
			i = i + 1
		} else if (nc(dat, i, "[")) {
			tokens = append(tokens, Token{TokenType.LBracket{}, "["})
			i = i + 1
		} else if (nc(dat, i, "]")) {
			tokens = append(tokens, Token{TokenType.RBracket{}, "]"})
			i = i + 1
		} else if (nc(dat, i, "(")) {
			tokens = append(tokens, Token{TokenType.LParen{}, "("})
			i = i + 1
		} else if (nc(dat, i, ")")) {
			tokens = append(tokens, Token{TokenType.RParen{}, ")"})
			i = i + 1
		} else if (nc(dat, i, "\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
			i = i + 1
		} else if (nc(dat, i, "\r\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\r\n"})
			i = i + 2
		} else if (nc(dat, i, ",")) {
			tokens = append(tokens, Token{TokenType.Comma{}, ","})
			i = i + 1
		} else if (nc(dat, i, ":")) {
			tokens = append(tokens, Token{TokenType.Colon{}, ":"})
			i = i + 1
		} else if (nc(dat, i, "=")) {
			tokens = append(tokens, Token{TokenType.Equals{}, "="})
			i = i + 1
		} else if (nc(dat, i, ".")) {
			tokens = append(tokens, Token{TokenType.Dot{}, "."})
			i = i + 1
		} else if (nc(dat, i, "\"")) {
			str := bs("\"")
			i = i + 1
			while {
				if (nc(dat, i, "\"")) {
					str = append(str, dat[i])
					i = i + 1
					break
				} else if (nc(dat, i, "\\\"")) {
					str = append(str, dat[i], dat[i + 1])
					i = i + 2
				} else {
					str = append(str, dat[i])
					i = i + 1
				}
			}
			tokens = append(tokens, Token{TokenType.StringLiteral{}, string(str)})
		} else {
            str := peekInfixSymbol(dat, i)
            if (len(str) > 0) {
                tokens = append(tokens, Token{TokenType.BinaryOp{}, str})
                i = i + len(str)
            } else {
                panic(sprintf("unexpected token: |%c|\n\ntokens so far: %#v", dat[i], tokens))
            }
		}
	}
	return tokens
}

enum Declaration {
	Enum(Enum),
	Import(Import),
	Struct(Struct),
	Function(Function),
}

struct FunctionParam {
    Name string,
    Type string, // TODO: this should be a Type probably?
}

struct Function {
    Name string,
    Params []FunctionParam,
    Returns []string,
    Body Block,
}

enum LValue {
  Variable(string),
}

struct FuncCall {
  LHS Expr,
  Params []Expr,
}

enum Expr {
  VarRef(string),
  FuncCall(FuncCall),
  // would be cool to get a warning if this was never constructed
  // rust does that and it's very useful
  IntLiteral(int),
}

struct Assignment {
  LValue []LValue,
  RValue Expr,
  IsReassignment bool,
}

func parseStatement(tokens []Token) (Statement, []Token) {
  isAssignment := false
  ass := Assignment {}
  isAssignment, ass, tokens = tryParseAssignment(tokens)
  if (isAssignment) {
    return Statement.Assignment { ass }, tokens
  }
  // otherwise parse an expression i guess?
  panic(fmt.Sprintf("trying to parse a statement, unhandled token: %#v", tokens[0]))
}

func tryParseAssignment(tokens []Token) (bool, Assignment, []Token) {
    origTokens := tokens
    lValues := []LValue{}
    t := Token{}
    ass := Assignment {}
    ass.IsReassignment = false
    while {
      if (peekTokens(tokens, []TokenType{TokenType.Ident{}, TokenType.Equals{}})) {
         ass.IsReassignment = true
         t, tokens = consumeToken(tokens, TokenType.Ident{})
         lValues = append(lValues, LValue.Variable { t.Value } )
         t, tokens = consumeToken(tokens, TokenType.Equals{})
         break
      } else if (peekTokens(tokens, []TokenType{TokenType.Ident{}, TokenType.Colon{}, TokenType.Equals{}})) {
        ass.IsReassignment = false
        t, tokens = consumeToken(tokens, TokenType.Ident{})
        lValues = append(lValues, LValue.Variable { t.Value } )
        t, tokens = consumeToken(tokens, TokenType.Colon{})
        t, tokens = consumeToken(tokens, TokenType.Equals{})
        break
      } else if (peekTokens(tokens, []TokenType{TokenType.Ident{}, TokenType.Comma{}})) {
        t, tokens = consumeToken(tokens, TokenType.Ident{})
        lValues = append(lValues, LValue.Variable { t.Value } )
        t, tokens = consumeToken(tokens, TokenType.Comma{})
      } else {
        return false, Assignment{}, origTokens
      }
    }

    ass.RValue, tokens = parseExpr(tokens)
    return true, ass, tokens
}

// because there's no way to declare enums
func sentinelExprJank() Expr {
    return Expr.VarRef { "" }
}

func parseExpr(tokens []Token) (Expr, []Token) {
    t := Token{}
    expr := sentinelExprJank()
    if (peekToken(tokens, TokenType.Ident{})) {
        t, tokens = consumeToken(tokens, TokenType.Ident{})
        expr = Expr.VarRef { t.Value }
    } else if (peekToken(tokens, TokenType.IntLiteral{})) {
        t, tokens = consumeToken(tokens, TokenType.IntLiteral{})
        expr = Expr.IntLiteral { atoi(t.Value) }
    }
    if (peekToken(tokens, TokenType.LParen{})) {
      funcCall := FuncCall{}
      funcCall, tokens = parseFuncCall(tokens, expr)
      return Expr.FuncCall { funcCall }, tokens
    }
    return expr, tokens
}

func parseFuncCall(tokens []Token, lhs Expr) (FuncCall, []Token) {
    t := Token{}
    t, tokens = consumeToken(tokens, TokenType.LParen{})
    funcCall := FuncCall{}
    funcCall.LHS = lhs
    while {
      if (peekToken(tokens, TokenType.RParen{})) {
        break
      }

      nextParam, tokens2 := parseExpr(tokens)
      funcCall.Params = append(funcCall.Params, nextParam)
      tokens = tokens2

      if (peekToken(tokens, TokenType.Comma{})) {
        t, tokens = consumeToken(tokens, TokenType.Comma{})
      } else {
        break
      }
    }
    t, tokens = consumeToken(tokens, TokenType.RParen{})
    return funcCall, tokens
}

enum Statement {
  Assignment(Assignment),
}

struct Block {
  Statements []Statement,
}

func parseBlock(tokens []Token) (Block, []Token) {
    stmts := []Statement{}
    t := Token{}
    t, tokens = consumeToken(tokens, TokenType.LCurly{})

    while {
        tokens = skipNewlines(tokens)
        stmt, tokens2 := parseStatement(tokens)
        tokens = tokens2
        stmts = append(stmts, stmt)
        if (peekToken(tokens, TokenType.RCurly{})) {
            break
        }
    }

    t, tokens = consumeToken(tokens, TokenType.RCurly{})
    return Block{stmts}, tokens
}

func parseBlockFake(tokens []Token) (Block, []Token) {
  // keeps a stacks of curly braces, and figures out when the matching curly brace is...
  // thing is we're not actually going to parse the block, just skip past it. Block is an empty
  // struct for now
  t, tokens := consumeToken(tokens, TokenType.LCurly{})
  curlyStack := []Token{t}
  while {
    if (peekToken(tokens, TokenType.LCurly{})) {
      t, tokens = consumeToken(tokens, TokenType.LCurly{})
      curlyStack = append(curlyStack, t)
    } else if (peekToken(tokens, TokenType.RCurly{})) {
      t, tokens = consumeToken(tokens, TokenType.RCurly{})
      curlyStack = slice(curlyStack, 0, len(curlyStack) - 1)
      if (len(curlyStack) == 0) {
        break
      }
    } else {
      typ := tokens[0].Type
      t, tokens = consumeToken(tokens, typ)
    }
  }
  return Block{}, tokens
}

struct Program {
	Declarations []Declaration,
}

struct Import {
  Name string,
}

struct Enum {
	Name string,
	Variants []EnumVariant,
}

struct EnumVariant {
    Name string,
    Type string, // TODO: this should be a Type probably?   (can be empty)
}

struct Struct {
    Name string,
    Fields []StructField,
}

struct StructField {
    Name string,
    Type string, // TODO: this should be a Type probably?
}

func parseImport(tokens []Token) (Import, []Token) {
  t, tokens := consumeToken(tokens, TokenType.Import{})
  t, tokens = consumeToken(tokens, TokenType.StringLiteral{})
  name := t.Value
  return Import{name}, tokens
}

func parseEnum(tokens []Token) (Enum, []Token) {
  t, tokens := consumeToken(tokens, TokenType.EnumDecl{})
  t, tokens = consumeToken(tokens, TokenType.Ident{})
  e := Enum{}
  e.Name = t.Value
  t, tokens = consumeToken(tokens, TokenType.LCurly{})
  while {
    if (peekToken(tokens, TokenType.RCurly{})) {
      t, tokens = consumeToken(tokens, TokenType.RCurly{})
      break
    }
    t, tokens = consumeToken(tokens, TokenType.Ident{})
    variant := EnumVariant{}
    variant.Name = t.Value

    if (peekToken(tokens, TokenType.LParen{})) {
      t, tokens = consumeToken(tokens, TokenType.LParen{})
      typ := ""
      typ, tokens = parseType(tokens)
      variant.Type = typ
      t, tokens = consumeToken(tokens, TokenType.RParen{})
    }

    e.Variants = append(e.Variants, variant)
    t, tokens = consumeToken(tokens, TokenType.Comma{})
  }
  return e, tokens
}

func parseStruct(tokens []Token) (Struct, []Token) {
  t, tokens := consumeToken(tokens, TokenType.Struct{})
  t, tokens = consumeToken(tokens, TokenType.Ident{})
  s := Struct{}
  s.Name = t.Value
  t, tokens = consumeToken(tokens, TokenType.LCurly{})
  while {
    if (peekToken(tokens, TokenType.RCurly{})) {
      t, tokens = consumeToken(tokens, TokenType.RCurly{})
      break
    }
    field := StructField{}
    t, tokens = consumeToken(tokens, TokenType.Ident{})
    field.Name = t.Value
    field.Type, tokens = parseType(tokens)
    s.Fields = append(s.Fields, field)
    t, tokens = consumeToken(tokens, TokenType.Comma{})
  }
  return s, tokens
}

func parseType(tokens []Token) (string, []Token) {
  // TODO: handle pointers
  name := ""
  t := Token{}
  while {
    if (peekToken(tokens, TokenType.Ident{})) {
      t, tokens = consumeToken(tokens, TokenType.Ident{})
      name = name + t.Value
    } else if (peekToken(tokens, TokenType.LBracket{})) {
      t, tokens = consumeToken(tokens, TokenType.LBracket{})
      name = name + t.Value
    } else if (peekToken(tokens, TokenType.RBracket{})) {
      t, tokens = consumeToken(tokens, TokenType.RBracket{})
      name = name + t.Value
    } else {
      break
    }
  }
  return name, tokens
}

func parseFunction(tokens []Token) (Function, []Token) {
    t, tokens := consumeToken(tokens, TokenType.FuncDecl{})
    t, tokens = consumeToken(tokens, TokenType.Ident{})
    f := Function{}
    f.Name = t.Value
    t, tokens = consumeToken(tokens, TokenType.LParen{})
    while {
        if (peekToken(tokens, TokenType.RParen{})) {
          t, tokens = consumeToken(tokens, TokenType.RParen{})
          break
        }
        param := FunctionParam{}
        t, tokens = consumeToken(tokens, TokenType.Ident{})
        param.Name = t.Value
        param.Type, tokens = parseType(tokens)
        f.Params = append(f.Params, param)
        if (peekToken(tokens, TokenType.Comma{})) {
          t, tokens = consumeToken(tokens, TokenType.Comma{})
        }
    }

    if (not(peekToken(tokens, TokenType.LCurly{}))) {
        typ := ""
        f.Returns, tokens = parseReturnTypes(tokens)
    }

    f.Body, tokens = parseBlock(tokens)
    return f, tokens
}

func parseReturnTypes(tokens []Token) ([]string, []Token) {
    types := []string{}
    typ := ""
    t := Token{}
    if (peekToken(tokens, TokenType.LParen{})) {
      t, tokens = consumeToken(tokens, TokenType.LParen{})
      while {
        typ, tokens = parseType(tokens)
        types = append(types, typ)
        if (peekToken(tokens, TokenType.Comma{})) {
          t, tokens = consumeToken(tokens, TokenType.Comma{})
        } else {
          break
        }
      }
      t, tokens = consumeToken(tokens, TokenType.RParen{})
    } else {
        typ, tokens = parseType(tokens)
        types = append(types, typ)
    }
    return types, tokens
}

func parseDeclaration(tokens []Token) (Declaration, []Token) {
	match (tokens[0].Type) {
		TokenType.Import{}: {
		  imp, tokens := parseImport(tokens)
		  return Declaration.Import { imp }, tokens
        },
        TokenType.EnumDecl{}: {
          e, tokens := parseEnum(tokens)
          return Declaration.Enum { e }, tokens
	    },
	    TokenType.Struct{}: {
          s, tokens := parseStruct(tokens)
          return Declaration.Struct { s }, tokens
	    },
	    TokenType.FuncDecl{}: {
	      f, tokens := parseFunction(tokens)
	      return Declaration.Function { f }, tokens
	    },
	}
  panic(fmt.Sprintf("unexpected token: %#v", tokens[0]))
}

func parseProgram(tokens []Token) Program {
	p := Program{}
	while {
	  tokens = skipNewlines(tokens)
	  if (len(tokens) == 0) {
          break
	  }

	  declaration, tokens2 := parseDeclaration(tokens)
	  tokens = tokens2
	  p.Declarations = append(p.Declarations, declaration)
	}
	return p
}

func skipNewlines(tokens []Token) []Token {
	while {
      if (len(tokens) == 0) {
          return tokens
      }
	  match (tokens[0].Type) {
	    TokenType.Newline: {
	      tokens = slice(tokens, 1)
	      continue
      },
	  }
	  break
	}
	return tokens
}

func peekTokens(tokens []Token, expectedTypes []TokenType) bool {
    i := 0
    while {
        if (i >= len(expectedTypes)) {
            return true
        }
        if (len(tokens) == 0) {
            return false
        }
        if (tokens[i].Type != expectedTypes[i]) {
            return false
        }
        i = i + 1
    }
}

func peekToken(tokens []Token, expectedType TokenType) bool {
	if (len(tokens) == 0) {
		panic("Unexpected end of input")
	}
	nl := TokenType.Newline{}
	if (expectedType != nl) {
	  tokens = skipNewlines(tokens)
	}
	return tokens[0].Type == expectedType
}

func consumeToken(tokens []Token, expectedType TokenType) (Token, []Token) {
  if (len(tokens) == 0) {
    panic("Unexpected end of input")
  }
  nl := TokenType.Newline{}
  if (expectedType != nl) {
    tokens = skipNewlines(tokens)
  }
  if (tokens[0].Type != expectedType) {
		panic(fmt.Sprintf("Was expecting token %#v, got %#v", expectedType, tokens[0]))
  }
  return tokens[0], slice(tokens, 1)
}

func main() {
	dat, err := os.ReadFile("lexer.goy")
	if (err != nil) {
		panic(err)
	}
	tokens := lex(dat)
	//print("Tokens:")
	//print(tokens)
	program := parseProgram(tokens)
	print("Program:")
	print(program)
}
