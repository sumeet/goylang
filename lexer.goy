enum TokenType {
	FuncDecl,
	LParen,
	RParen,
	LCurly,
	RCurly,
	LBracket,
	RBracket,
	Ident,
	IntLiteral,
	Assignment,
	Reassignment,
	BinaryOp,
	Newline,
	Comma,
	StringLiteral,
	EnumDecl,
	Match,
	Dot,
	Colon,
}

struct Token {
	Type TokenType,
	Value     string,
}

func lex(dat []byte) []Token {
	tokens := []Token{}
	i := 0
	while {
		if (ge(i, len(dat))) {
			break
		} else if (or(nc(dat, i, " "), nc(dat, i, "\t"))) {
			i = add(i, 1)
			continue
		} else if (nc(dat, i, "//")) {
			while {
				if (nc(dat, i, "\n")) {
					tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
					break
				} else {
					i = add(i, 1)
				}
			}
		} else if (isAlpha(g(dat, i))) {
			ident := []byte{}
			while {
				if (isAlpha(g(dat, i))) {
					ident = append(ident, g(dat, i))
					i = add(i, 1)
				} else {
					if (eq(string(ident), "enum")) {
						tokens = append(tokens, Token{TokenType.EnumDecl{}, "enum"})
					} else {
						tokens = append(tokens, Token{TokenType.Ident{}, string(ident)})
					}
					break
				}
			}
			continue
		} else if (isDigit(g(dat, i))) {
		  n := []byte{}
		  while {
			if (isDigit(g(dat, i))) {
				n = append(n, g(dat, i))
				i = add(i, 1)
			} else {
			  tokens = append(tokens, Token{TokenType.IntLiteral{}, string(n)})
			  break
			}
		  }
		} else if (nc(dat, i, "{")) {
			tokens = append(tokens, Token{TokenType.LCurly{}, "{"})
			i = add(i, 1)
		} else if (nc(dat, i, "}")) {
			tokens = append(tokens, Token{TokenType.RCurly{}, "}"})
			i = add(i, 1)
		} else if (nc(dat, i, "[")) {
			tokens = append(tokens, Token{TokenType.LBracket{}, "["})
			i = add(i, 1)
		} else if (nc(dat, i, "]")) {
			tokens = append(tokens, Token{TokenType.RBracket{}, "]"})
			i = add(i, 1)
		} else if (nc(dat, i, "(")) {
			tokens = append(tokens, Token{TokenType.LParen{}, "("})
			i = add(i, 1)
		} else if (nc(dat, i, ")")) {
			tokens = append(tokens, Token{TokenType.RParen{}, ")"})
			i = add(i, 1)
		} else if (nc(dat, i, "\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\n"})
			i = add(i, 1)
		} else if (nc(dat, i, "\r\n")) {
			tokens = append(tokens, Token{TokenType.Newline{}, "\r\n"})
			i = add(i, 2)
		} else if (nc(dat, i, ",")) {
			tokens = append(tokens, Token{TokenType.Comma{}, ","})
			i = add(i, 1)
		} else if (nc(dat, i, ":=")) {
			tokens = append(tokens, Token{TokenType.Reassignment{}, ":="})
			i = add(i, 2)
		} else if (nc(dat, i, ":")) {
			tokens = append(tokens, Token{TokenType.Colon{}, ":"})
			i = add(i, 1)
		} else if (nc(dat, i, "=")) {
			tokens = append(tokens, Token{TokenType.Assignment{}, "="})
			i = add(i, 1)
		} else if (nc(dat, i, ".")) {
			tokens = append(tokens, Token{TokenType.Dot{}, "."})
			i = add(i, 1)
		} else if (nc(dat, i, "\"")) {
			str := bs("\"")
			i = add(i, 1)
			while {
				if (nc(dat, i, "\"")) {
					str = append(str, g(dat, i))
					i = add(i, 1)
					break
				} else if (nc(dat, i, "\\\"")) {
					str = append(str, g(dat, i), g(dat, add(i, 1)))
					i = add(i, 2)
				} else {
					str = append(str, g(dat, i))
					i = add(i, 1)
				}
			}
			tokens = append(tokens, Token{TokenType.StringLiteral{}, string(str)})
		} else {
			panic(sprintf("unexpected token: |%c|\n\ntokens so far: %#v", g(dat, i), tokens))
		}
	}
	return tokens
}

enum Statement {
	Enum(Enum),
}

struct Program {
	Statements []Statement,
}

struct Enum {
	Name string,
}

func parseProgram(tokens []Token) Program {
	p := Program{}
	thisToken := Token{}
	match (g(tokens, 0).Type) {
		TokenType.EnumDecl{}: {
			thisToken, tokens = parseEnum(tokens)
			//p = append(p, Statement.Enum{ parseEnum(tokens) })
		},
	}
	return p
}

//func parseEnum(tokens []Token) (Enum, []Token) {
//	e := Enum{}
//	thisToken := Token{}
//	match (g(tokens, 0).Type) {
//		TokenType.EnumDecl{}: {
//			//e.Name, tokens = parseIdent(tokens)
//		},
//	}
//	return e, tokens
//}

//func consumeToken(tokens []Token, expectedType TokenType) []Token {
//	if eq(len(tokens), 0) {
//		panic("Unexpected end of input")
//	}
//	thisToken := Token{}
//
//	if eq(g(tokens, 0).Type, expectedType) {
//		thisToken, tokens = pop(tokens)
//	} else {
//		panic(sprintf("Expected %v, got %v", expectedType, g(tokens, 0).Type))
//	}
//}

func main() {
	dat := readfile("lexer.goy")
	tokens := lex(dat)
	print("Tokens:")
	print(tokens)
}
